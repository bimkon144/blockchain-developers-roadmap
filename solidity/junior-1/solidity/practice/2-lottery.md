# Lottery

- Необходимо пройти [Lesson 9: Hardhat Smart Contract Lottery](https://github.com/smartcontractkit/full-blockchain-solidity-course-js#lesson-9-hardhat-smart-contract-lottery).

    Для выполнения задания следует выполнить следующие шаги:
    - Настроить среду разработки hardhat с нуля (лучше будет если ты не будешь полностью копировать проект из репозитория курса, а будешь только подсматривать туда по необходимости). 
    - Проект настроить под TypeScript (в репозитории курса есть отдельная ветка).
	- Итеративно, по мере прохождения урока написать контракт Raffle и скрипты деплоя к нему.
	- Скопировать юнит тесты из курса и добиться успешного выполнения всех тестов в локальной сети. Разобраться как тесты взаимодействуют с деплой-скриптами и как сделать автоматический запуск юнит-тестов или интеграционных тестов в зависимости от `chainId`. 
    Подсказка: некоторые тесты будут падать т.к. после выхода курса изменились некоторые зависимости, нужно найти причину и пофиксить, чтобы все тесты выполнялись успешно. Но перед тем как искать изменения в сторонних контрактах убедись, что в твоем все работает правильно.
    - Настроить `solidity-coverage`.
    - Разобраться как работает `solidity-gas-reporter`.
    - Разобраться как использовать `hardhat-contact-sizer`.
	- Выполнить интеграционные тесты в тестовой сети: 
        1. скопировать интеграционные тесты. 
        2. Здеплоить свой контракт.
        3. Настроить vrf.chain.link
        4. Настроить keepers.chain.link
        4. Настроить отложенный запуск и запустить интеграционные тесты.
- Пройти мини-урок [Introduction to Events](https://github.com/smartcontractkit/full-blockchain-solidity-course-js#introduction-to-events)
- Пройтись по литературе на которую приведены ссылки в задании курса.

## Какие навыки даст задание?

1. Настройка проекта hardhat с нуля.
2. Работа с событиями (урок в уроке).
3. Получение рандомного числа с помощью оракла на примере Сhinlink random
4. Использование Chainlink Keeper для автоматизации работы с контрактом. 
5. Написание юнит-тестов.
6. Написание интеграционных тестов.
7. Написание контракта децентрализованной лотереи.

## Вопросы по теории

### 1. hardhat:

1. Зачем нужен метод `getNamedAccounts`?
2. Для чего нужен файл `helper-hardhat-config`?
3. Зачем писать деплой скрипты?
4. Как использовать теги в деплой скриптах, для чего нужен `fixture`?
5. Как настроить верификацию контракта при деплое в тестнет и мейннет?
6. Для чего нужен `.env` и что мы в нем указываем? Какая особенность есть с этим файлом?
7. Как использовать `getContract`?

### 2. События: 

1. Где хранятся события?
2. Как получать и обрабатывать события из транзакции?
3. Для чего нужно индексировать параметры? В чем отличие проиндексированных параметров в событии от непроиндексированных?
4. Сколько индексированных параметров можно указать в событии?
5. Что нужно для того чтобы декодировать НЕиндексированные параметры?
6. Если открыть транзакцию в `ehterscan` - как будут выглядеть проиндексированные и непроиндексированные события? Какие события требуют меньше газа - проиндексированные или непроиндексированные и почему? 
7. `transactionReceipt.events[0].args.subId` - если бы параметр `subId` не был проиндексирован попал бы он в массив `events`?

### 3. Получение рандомного числа:

1. ChainlinkVRF как подключить и как использовать?
2. Как получить рандомное слово с помощью ChainlinkVRF?
3. Как сгенерировать рандомное число на основе рандомного слова?
4. Как работает функция `fulfillRandomWords`?

### 4. Автоматизация с помощью кипера

1. Для чего нужна автоматизация на смарт-контракте?
2. В каких случаях ее можно применить?
3. Как работает кипер?
4. Что делают функции `checkUpkeep` и `performUpkeep` в Chainlink keeper? Как это использовать?

### 5. Тесты:

1. Когда мы делаем `evm_increaseTime` а когда `evm_mine` и зачем делать и то и другое?
2. Зачем нужны `gas_line`, `gas_price_link` и `callbackGasLimit`?
3. Как вызвать один конкретный тест чтобы не прогонять каждый раз все тесты?
4. Что такое `describe.skip` и как его использовать?
5. Как в тестах вызывать контракт с разных адресов?
7. Для чего нужен `callStatic`?
8. Что проверяет эта строка в тестах, для чего она нужна?
    ```js
        await expect(raffle.getPlayer(0)).to.be.reverted
    ```
9. Зачем в конфиге выставлять следующую настройку, в каком виде тестов она используется?
    ```js
        mocha: {
            timeout: 200000,
        },
    ```
10. Чем полезен TypeScript в тестах?

### 6. Общие вопросы по заданию:

1. Какой будет флоу у контракта Raffle (порядок выполнения функций и определения победителя лотереи)?
2. Зачем менять `RuffleState` с `OPEN` на `CALCULATING` в функции `performUpkeep`?
3. Чем вкладка `transactions` в etherscan отличается от вкладки `internal txns`?
5. Зачем нам столько функций-геттеров если мы можем просто объявить переменную как `public` и она будет автоматически обернута в геттер?

## Литература помимо той, что дана в курсе:

- [gas optimization](https://0xmacro.com/blog/solidity-gas-optimizations-cheat-sheet/)
- [callStatic](https://ethereum.stackexchange.com/questions/111916/hardhat-test-returns-transaction-instead-of-return-value)
